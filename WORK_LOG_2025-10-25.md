# 프론트엔드 작업 로그 - 2025년 10월 25일

## 작업 개요
백엔드 API 변경에 따른 프론트엔드 인증 및 사용자 서비스 연동 수정

---

## 1. 문제: 회원가입 후 사용자 이름 미표시

### 문제 상황
- 회원가입은 성공하지만 로그인 후 사용자 이름이 표시되지 않음
- 백엔드 응답 구조와 프론트엔드 기대 구조 불일치
- 임시 토큰 사용으로 인한 인증 문제

### 원인 분석
1. 백엔드: `ApiResponse<AuthResponse>` 형식으로 응답
   ```json
   {
     "success": true,
     "message": "회원가입이 성공적으로 완료되었습니다.",
     "data": {
       "accessToken": "...",
       "refreshToken": "...",
       "user": { ... }
     }
   }
   ```

2. 프론트엔드: `AuthResponse` 형식을 직접 기대
   ```typescript
   {
     "accessToken": "...",
     "refreshToken": "...",
     "user": { ... }
   }
   ```

### 해결 과정

#### 1.1 authService.ts 수정
**파일:** `src/services/authService.ts`

**변경 전:**
```typescript
async register(data: RegisterRequest): Promise<AuthResponse> {
  const response = await apiClient.post<AuthResponse>(API_ROUTES.AUTH.REGISTER, data);
  
  // 회원가입 후 자동 로그인
  setLocalStorage(STORAGE_KEYS.ACCESS_TOKEN, response.data.accessToken);
  setLocalStorage(STORAGE_KEYS.REFRESH_TOKEN, response.data.refreshToken);
  setLocalStorage(STORAGE_KEYS.USER, response.data.user);
  
  return response.data;
}
```

**변경 후:**
```typescript
async register(data: RegisterRequest): Promise<AuthResponse> {
  const response = await apiClient.post(API_ROUTES.AUTH.REGISTER, data);
  
  // 백엔드 응답 구조: { success: true, message: "...", data: AuthResponse }
  const authData = response.data.data || response.data;
  
  // 회원가입 후 자동 로그인 상태로 설정
  setLocalStorage(STORAGE_KEYS.ACCESS_TOKEN, authData.accessToken);
  setLocalStorage(STORAGE_KEYS.REFRESH_TOKEN, authData.refreshToken);
  setLocalStorage(STORAGE_KEYS.USER, authData.user);
  
  return authData;
}
```

**주요 변경점:**
- `response.data.data`로 실제 `AuthResponse` 추출
- 백엔드의 `ApiResponse` 래퍼 구조 처리
- 실제 JWT 토큰 저장 (임시 토큰 제거)

---

## 2. 문제: TypeScript 타입 불일치

### 문제 상황
- `RegisterFormData` 인터페이스에 `username` 필드 사용
- 실제 코드에서는 `name` 필드 사용
- 컴파일 에러 발생

### 해결 과정

#### 2.1 RegisterPage.tsx 인터페이스 수정
**파일:** `src/pages/RegisterPage.tsx`

**변경 전:**
```typescript
interface RegisterFormData {
  email: string;
  password: string;
  passwordConfirm: string;
  username: string;
  phone: string;
}
```

**변경 후:**
```typescript
interface RegisterFormData {
  email: string;
  password: string;
  passwordConfirm: string;
  name: string;  // username -> name
  phone: string;
}
```

#### 2.2 RegisterRequest 인터페이스 수정
**파일:** `src/services/authService.ts`

**변경 전:**
```typescript
export interface RegisterRequest {
  email: string;
  password: string;
  username: string;
  phone?: string;
  preferredRegions: PreferredRegion[];
}
```

**변경 후:**
```typescript
export interface RegisterRequest {
  email: string;
  password: string;
  name: string;
  username?: string; // 선택사항 (없으면 email 사용)
  phone?: string;
  preferredRegions: PreferredRegion[];
}
```

#### 2.3 User 인터페이스 수정
**파일:** `src/services/authService.ts`

```typescript
export interface User {
  id: string;
  email: string;
  name: string;        // 추가
  username: string;
  phone?: string;
  preferredRegions?: PreferredRegion[];
  profileImage?: string;
  role: 'USER' | 'ADMIN';
  createdAt: string;
  updatedAt: string;
}
```

---

## 3. 문제: 사용자 프로필 API 404 에러

### 문제 상황
```
GET https://.../api/user/me 404 (Not Found)
GET https://.../api/user/me/preferred-regions 404 (Not Found)
```

### 해결 과정

#### 3.1 userService.ts 생성 및 API 연동
**파일:** `src/services/userService.ts`

```typescript
import axios from 'axios';

const API_URL = import.meta.env.VITE_API_BASE_URL || '';

// 선호 지역 인터페이스
export interface PreferredRegion {
  priority: number;
  city: string;
  cityName: string;
  district: string;
  districtName: string;
}

export interface PreferredRegionsResponse {
  preferredRegions: PreferredRegion[];
}

export interface UpdateProfileRequest {
  name?: string;
  phone?: string;
  phoneNumber?: string;
  username?: string;
  preferredRegions?: PreferredRegion[];
}

export interface ChangePasswordRequest {
  currentPassword: string;
  newPassword: string;
}

// 사용자 선호 지역 조회
export const getMyPreferredRegions = async (): Promise<PreferredRegionsResponse> => {
  try {
    const userStr = localStorage.getItem('user');
    if (!userStr) {
      throw new Error('로그인이 필요합니다.');
    }
    const user = JSON.parse(userStr);
    const email = user.email;
    
    const response = await axios.get(`${API_URL}/api/user/auth/me/preferred-regions`, {
      params: { email }
    });
    return response.data;
  } catch (error: any) {
    if (error.response?.status === 404) {
      console.warn('User Service: /api/user/me/preferred-regions 엔드포인트에서 데이터를 찾을 수 없습니다.');
      // 임시 더미 데이터 반환
      return {
        preferredRegions: [
          { priority: 1, city: "11", cityName: "서울특별시", district: "11680", districtName: "강남구" },
          { priority: 2, city: "11", cityName: "서울특별시", district: "11740", districtName: "강동구" },
          { priority: 3, city: "26", cityName: "부산광역시", district: "26440", districtName: "해운대구" },
        ],
      };
    }
    throw error;
  }
};

// 사용자 정보 조회
export const getMyInfo = async () => {
  try {
    const userStr = localStorage.getItem('user');
    if (!userStr) {
      throw new Error('로그인이 필요합니다.');
    }
    const user = JSON.parse(userStr);
    const email = user.email;
    
    const response = await axios.get(`${API_URL}/api/user/auth/me`, {
      params: { email }
    });
    return response.data.data || response.data;
  } catch (error: any) {
    if (error.response?.status === 404) {
      console.warn('User Service: /api/user/me 엔드포인트에서 데이터를 찾을 수 없습니다.');
      const userStr = localStorage.getItem('user');
      if (userStr) {
        return JSON.parse(userStr);
      }
    }
    throw error;
  }
};

// 프로필 업데이트
export const updateUserProfile = async (data: UpdateProfileRequest) => {
  const userStr = localStorage.getItem('user');
  if (!userStr) {
    throw new Error('로그인이 필요합니다.');
  }
  const user = JSON.parse(userStr);
  const email = user.email;
  
  const response = await axios.put(`${API_URL}/api/user/auth/me`, data, {
    params: { email }
  });
  return response.data.data || response.data;
};

// 비밀번호 변경
export const changeUserPassword = async (data: ChangePasswordRequest) => {
  const userStr = localStorage.getItem('user');
  if (!userStr) {
    throw new Error('로그인이 필요합니다.');
  }
  const user = JSON.parse(userStr);
  const email = user.email;
  
  const response = await axios.put(`${API_URL}/api/user/auth/me/password`, data, {
    params: { email }
  });
  return response.data;
};

// 프로필 이미지 업로드
export const uploadProfileImage = async (file: File) => {
  const formData = new FormData();
  formData.append('file', file);
  const response = await axios.post(`${API_URL}/api/user/me/profile-image`, formData, {
    headers: {
      'Content-Type': 'multipart/form-data',
    },
  });
  return response.data.imageUrl;
};

// Aliases for backward compatibility
export const getProfile = getMyInfo;
export const updateProfile = updateUserProfile;
export const changePassword = changeUserPassword;

export default {
  getMyPreferredRegions,
  getMyInfo,
  updateUserProfile,
  changeUserPassword,
  uploadProfileImage,
  getProfile,
  updateProfile,
  changePassword,
};
```

**주요 특징:**
- 로컬 스토리지에서 사용자 이메일 추출
- 이메일을 쿼리 파라미터로 전달
- 404 에러 시 폴백 처리 (더미 데이터 또는 로컬 스토리지 데이터)
- `ApiResponse` 구조 처리 (`response.data.data`)

---

## 4. 문제: ProfilePage TypeScript 에러

### 문제 상황
```
Property 'name' does not exist on type 'FieldErrors<RegisterFormData>'
Property 'phoneNumber' does not exist on type 'UpdateProfileRequest'
```

### 해결 과정

#### 4.1 ProfilePage.tsx 수정
**파일:** `src/pages/ProfilePage.tsx`

**변경 전:**
```typescript
<TextField
  fullWidth
  label="이름"
  {...registerProfile('username', { ... })}
  error={!!profileErrors.username}
  helperText={profileErrors.username?.message}
/>

<TextField
  fullWidth
  label="전화번호"
  {...registerProfile('phone', { ... })}
  error={!!profileErrors.phone}
  helperText={profileErrors.phone?.message}
/>
```

**변경 후:**
```typescript
<TextField
  fullWidth
  label="이름"
  {...registerProfile('name', { ... })}
  error={!!profileErrors.name}
  helperText={profileErrors.name?.message as string}
/>

<TextField
  fullWidth
  label="전화번호"
  {...registerProfile('phoneNumber', { ... })}
  error={!!profileErrors.phoneNumber}
  helperText={profileErrors.phoneNumber?.message as string}
/>
```

**주요 변경점:**
- `username` → `name`
- `phone` → `phoneNumber`
- `helperText`에 타입 캐스팅 추가 (`as string`)

#### 4.2 userSlice.ts 수정
**파일:** `src/store/slices/userSlice.ts`

```typescript
import userService, { UpdateProfileRequest, ChangePasswordRequest } from '../../services/userService';

export const getProfile = createAsyncThunk(
  'user/getProfile',
  async (_, { rejectWithValue }) => {
    try {
      const profile = await userService.getProfile();
      return profile;
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.message || '프로필 조회 실패');
    }
  }
);

export const updateProfile = createAsyncThunk(
  'user/updateProfile',
  async (data: UpdateProfileRequest, { rejectWithValue }) => {
    try {
      const profile = await userService.updateProfile(data);
      return profile;
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.message || '프로필 업데이트 실패');
    }
  }
);

export const changePassword = createAsyncThunk(
  'user/changePassword',
  async (data: ChangePasswordRequest, { rejectWithValue }) => {
    try {
      await userService.changePassword(data);
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.message || '비밀번호 변경 실패');
    }
  }
);
```

---

## 5. 지역 좌표 매핑 및 추천 서비스 연동

### 5.1 regionCoordinates.ts 생성
**파일:** `src/utils/regionCoordinates.ts`

```typescript
export interface Coordinate {
  latitude: number;
  longitude: number;
}

export const DEFAULT_COORDINATE: Coordinate = {
  latitude: 37.5665, // 서울 시청
  longitude: 126.9780,
};

const regionCoordinates: { [districtCode: string]: Coordinate } = {
  // 서울특별시
  "11000": { latitude: 37.5665, longitude: 126.9780 },
  "11110": { latitude: 37.5799, longitude: 126.9896 }, // 종로구
  "11140": { latitude: 37.5637, longitude: 126.9976 }, // 중구
  "11680": { latitude: 37.4979, longitude: 127.0276 }, // 강남구
  // ... 더 많은 지역
};

export const getCoordinatesByDistrict = (districtCode: string): Coordinate | undefined => {
  return regionCoordinates[districtCode];
};
```

### 5.2 HomePage.tsx에 추천 지역 지도 추가
**파일:** `src/pages/HomePage.tsx`

```typescript
const [preferredRegions, setPreferredRegions] = useState<PreferredRegion[]>([]);
const [mapCenter, setMapCenter] = useState(DEFAULT_COORDINATE);

useEffect(() => {
  if (isAuthenticated) {
    fetchPreferredRegions();
  }
}, [isAuthenticated]);

const fetchPreferredRegions = async () => {
  try {
    const data = await getMyPreferredRegions();
    setPreferredRegions(data.preferredRegions);
    
    if (data.preferredRegions.length > 0) {
      const firstRegion = data.preferredRegions.find(r => r.priority === 1);
      if (firstRegion) {
        const coordinate = getCoordinatesByDistrict(firstRegion.district);
        if (coordinate) {
          setMapCenter({
            latitude: coordinate.latitude,
            longitude: coordinate.longitude,
          });
        }
      }
    }
  } catch (err: any) {
    console.error('선호 지역 조회 실패:', err);
  }
};

// UI 렌더링
{isAuthenticated && preferredRegions.length > 0 && (
  <Paper sx={{ p: 3, mb: 4 }}>
    <Typography variant="h5" fontWeight="bold">
      내 관심 지역 추천
    </Typography>
    
    <Grid container spacing={3}>
      {/* 지도 */}
      <Grid item xs={12} md={8}>
        <Box sx={{ width: '100%', height: 400 }}>
          <iframe
            width="100%"
            height="100%"
            src={`https://www.google.com/maps?q=${mapCenter.latitude},${mapCenter.longitude}&hl=ko&z=14&output=embed`}
            allowFullScreen
          />
        </Box>
      </Grid>
      
      {/* 선호 지역 목록 */}
      <Grid item xs={12} md={4}>
        {preferredRegions.map((region) => (
          <Card key={region.priority}>
            <CardContent>
              <Typography variant="h6">
                {region.priority}순위
              </Typography>
              <Typography>
                {region.cityName} {region.districtName}
              </Typography>
              <Button
                onClick={() => {
                  const coordinate = getCoordinatesByDistrict(region.district);
                  if (coordinate) {
                    setMapCenter(coordinate);
                  }
                }}
              >
                지도에서 보기
              </Button>
            </CardContent>
          </Card>
        ))}
      </Grid>
    </Grid>
  </Paper>
)}
```

---

## 6. 커뮤니티 게시글에 위치 정보 추가

### 6.1 communityService.ts 인터페이스 수정
**파일:** `src/services/communityService.ts`

```typescript
export interface Post {
  id: number;
  title: string;
  content: string;
  // ... 기존 필드
  latitude?: number;    // 추가
  longitude?: number;   // 추가
  address?: string;     // 추가
}

export interface CreatePostRequest {
  title: string;
  content: string;
  // ... 기존 필드
  latitude?: number;    // 추가
  longitude?: number;   // 추가
  address?: string;     // 추가
}
```

### 6.2 CommunityWritePage.tsx에 장소 검색 추가
**파일:** `src/pages/CommunityWritePage.tsx`

```typescript
const [selectedPlace, setSelectedPlace] = useState<google.maps.places.PlaceResult | null>(null);
const [placeSearchInput, setPlaceSearchInput] = useState('');
const placeInputRef = useRef<HTMLInputElement>(null);

useEffect(() => {
  if (!placeInputRef.current || !window.google) return;

  const autocomplete = new window.google.maps.places.Autocomplete(placeInputRef.current, {
    componentRestrictions: { country: 'kr' },
    fields: ['formatted_address', 'geometry', 'name', 'place_id'],
  });

  autocomplete.addListener('place_changed', () => {
    const place = autocomplete.getPlace();
    if (place.geometry && place.geometry.location) {
      setSelectedPlace(place);
      setFormData((prev) => ({
        ...prev,
        latitude: place.geometry!.location!.lat(),
        longitude: place.geometry!.location!.lng(),
        address: place.formatted_address || place.name || '',
      }));
    }
  });
}, []);

// UI
<TextField
  fullWidth
  inputRef={placeInputRef}
  label="장소 검색 (예: 스타벅스 강남점)"
  value={placeSearchInput}
  onChange={(e) => setPlaceSearchInput(e.target.value)}
  placeholder="장소 이름이나 주소를 입력하세요"
  InputProps={{
    startAdornment: <LocationOnIcon />,
  }}
/>

{selectedPlace && formData.address && (
  <Chip
    icon={<LocationOnIcon />}
    label={formData.address}
    onDelete={handleClearLocation}
    color="primary"
  />
)}
```

### 6.3 CommunityDetailPage.tsx에 지도 표시
**파일:** `src/pages/CommunityDetailPage.tsx`

```typescript
{post.latitude && post.longitude && (
  <Box sx={{ mt: 3, mb: 3 }}>
    <Typography variant="subtitle2" fontWeight="bold">
      <Place color="primary" />
      위치 정보
    </Typography>
    {post.address && (
      <Typography variant="body2" color="text.secondary">
        {post.address}
      </Typography>
    )}
    <Box sx={{ width: '100%', height: 300 }}>
      <iframe
        width="100%"
        height="100%"
        src={`https://www.google.com/maps?q=${post.latitude},${post.longitude}&hl=ko&z=16&output=embed`}
        allowFullScreen
      />
    </Box>
  </Box>
)}
```

---

## 배포 설정

### GitHub Actions Workflow
**파일:** `.github/workflows/deploy.yml`

```yaml
name: Deploy Frontend

on:
  push:
    branches:
      - main
    paths:
      - 'src/**'
      - 'public/**'
      - 'package.json'
      - 'vite.config.ts'
      - '.github/workflows/deploy.yml'

jobs:
  deploy:
    runs-on: self-hosted
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Create .env file
        run: |
          echo "VITE_API_BASE_URL=" > .env
      
      - name: Build
        run: npm run build
      
      - name: Deploy to Nginx
        run: |
          sudo rm -rf /var/www/maltan-frontend/*
          sudo cp -r dist/* /var/www/maltan-frontend/
          sudo chown -R www-data:www-data /var/www/maltan-frontend
          sudo chmod -R 755 /var/www/maltan-frontend
          sudo systemctl reload nginx
```

---

## 환경 변수

### .env (개발)
```env
VITE_API_BASE_URL=http://localhost:8080
```

### .env (프로덕션)
```env
VITE_API_BASE_URL=
```
*프로덕션에서는 빈 문자열로 설정하여 상대 경로 사용 (Nginx 프록시)*

---

## 주요 개선 사항

1. **인증 시스템 완성**
   - JWT 토큰 기반 인증
   - 로컬 스토리지에 토큰 및 사용자 정보 저장
   - 자동 로그인 유지

2. **타입 안정성 향상**
   - TypeScript 인터페이스 정확히 정의
   - 백엔드 API 응답 구조와 일치
   - 컴파일 에러 제거

3. **사용자 경험 개선**
   - 회원가입 후 사용자 이름 정확히 표시
   - 선호 지역 기반 지도 표시
   - 커뮤니티 게시글에 위치 정보 추가

4. **에러 처리 강화**
   - API 호출 실패 시 폴백 처리
   - 404 에러 시 더미 데이터 또는 로컬 데이터 사용
   - 사용자 친화적인 에러 메시지

5. **코드 재사용성**
   - userService 모듈화
   - 공통 유틸리티 함수 분리
   - Backward compatibility를 위한 alias 제공

---

## 테스트 체크리스트

- [x] 회원가입 성공 시 사용자 이름 표시
- [x] JWT 토큰 로컬 스토리지 저장
- [x] 선호 지역 기반 지도 표시
- [x] 커뮤니티 게시글 작성 시 장소 검색
- [x] 게시글 상세보기에서 지도 표시
- [x] 프로필 페이지에서 정보 수정
- [x] TypeScript 컴파일 에러 없음
- [x] 프로덕션 빌드 성공

---

## 알려진 이슈 및 제한사항

1. **로그인 기능 미구현**
   - 현재는 회원가입만 가능
   - 로그인 엔드포인트 백엔드 구현 필요

2. **토큰 갱신 미구현**
   - Access Token 만료 시 처리 로직 없음
   - Refresh Token 사용 로직 필요

3. **프로필 이미지 업로드 미구현**
   - UI는 있지만 실제 업로드 기능 없음
   - 백엔드 파일 업로드 엔드포인트 필요

4. **오프라인 지원 없음**
   - 네트워크 연결 필수
   - Service Worker 구현 필요

---

## 다음 단계 (TODO)

1. **로그인 페이지 구현**
   - 이메일/비밀번호 입력
   - JWT 토큰 발급 및 저장
   - 로그인 상태 유지

2. **토큰 갱신 로직**
   - Access Token 만료 감지
   - Refresh Token으로 자동 갱신
   - Axios interceptor 구현

3. **프로필 이미지 업로드**
   - 파일 선택 및 미리보기
   - 이미지 업로드 API 연동
   - 프로필 이미지 표시

4. **에러 바운더리**
   - React Error Boundary 구현
   - 전역 에러 핸들링
   - 사용자 친화적인 에러 페이지

5. **성능 최적화**
   - 코드 스플리팅
   - 이미지 최적화
   - 번들 사이즈 감소

6. **접근성 개선**
   - ARIA 레이블 추가
   - 키보드 네비게이션 지원
   - 스크린 리더 호환성

